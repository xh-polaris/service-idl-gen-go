// Code generated by Kitex v0.12.1. DO NOT EDIT.

package coreapi

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	core_api "github.com/xh-polaris/service-idl-gen-go/kitex_gen/schedule/core_api"
	proto "google.golang.org/protobuf/proto"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"SignUp": kitex.NewMethodInfo(
		signUpHandler,
		newSignUpArgs,
		newSignUpResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SignIn": kitex.NewMethodInfo(
		signInHandler,
		newSignInArgs,
		newSignInResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateSchedule": kitex.NewMethodInfo(
		createScheduleHandler,
		newCreateScheduleArgs,
		newCreateScheduleResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateScheduleFromOrigin": kitex.NewMethodInfo(
		createScheduleFromOriginHandler,
		newCreateScheduleFromOriginArgs,
		newCreateScheduleFromOriginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateSchedules": kitex.NewMethodInfo(
		createSchedulesHandler,
		newCreateSchedulesArgs,
		newCreateSchedulesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateSchedule": kitex.NewMethodInfo(
		updateScheduleHandler,
		newUpdateScheduleArgs,
		newUpdateScheduleResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetSchedules": kitex.NewMethodInfo(
		getSchedulesHandler,
		newGetSchedulesArgs,
		newGetSchedulesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	coreApiServiceInfo                = NewServiceInfo()
	coreApiServiceInfoForClient       = NewServiceInfoForClient()
	coreApiServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return coreApiServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return coreApiServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return coreApiServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "core_api"
	handlerType := (*core_api.CoreApi)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "schedule.core_api",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.12.1",
		Extra:           extra,
	}
	return svcInfo
}

func signUpHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(core_api.SignUpReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(core_api.CoreApi).SignUp(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SignUpArgs:
		success, err := handler.(core_api.CoreApi).SignUp(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SignUpResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSignUpArgs() interface{} {
	return &SignUpArgs{}
}

func newSignUpResult() interface{} {
	return &SignUpResult{}
}

type SignUpArgs struct {
	Req *core_api.SignUpReq
}

func (p *SignUpArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(core_api.SignUpReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *SignUpArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *SignUpArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *SignUpArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SignUpArgs) Unmarshal(in []byte) error {
	msg := new(core_api.SignUpReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SignUpArgs_Req_DEFAULT *core_api.SignUpReq

func (p *SignUpArgs) GetReq() *core_api.SignUpReq {
	if !p.IsSetReq() {
		return SignUpArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SignUpArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SignUpArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SignUpResult struct {
	Success *core_api.SignUpResp
}

var SignUpResult_Success_DEFAULT *core_api.SignUpResp

func (p *SignUpResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(core_api.SignUpResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *SignUpResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *SignUpResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *SignUpResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SignUpResult) Unmarshal(in []byte) error {
	msg := new(core_api.SignUpResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SignUpResult) GetSuccess() *core_api.SignUpResp {
	if !p.IsSetSuccess() {
		return SignUpResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SignUpResult) SetSuccess(x interface{}) {
	p.Success = x.(*core_api.SignUpResp)
}

func (p *SignUpResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SignUpResult) GetResult() interface{} {
	return p.Success
}

func signInHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(core_api.SignInReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(core_api.CoreApi).SignIn(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SignInArgs:
		success, err := handler.(core_api.CoreApi).SignIn(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SignInResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSignInArgs() interface{} {
	return &SignInArgs{}
}

func newSignInResult() interface{} {
	return &SignInResult{}
}

type SignInArgs struct {
	Req *core_api.SignInReq
}

func (p *SignInArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(core_api.SignInReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *SignInArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *SignInArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *SignInArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SignInArgs) Unmarshal(in []byte) error {
	msg := new(core_api.SignInReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SignInArgs_Req_DEFAULT *core_api.SignInReq

func (p *SignInArgs) GetReq() *core_api.SignInReq {
	if !p.IsSetReq() {
		return SignInArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SignInArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SignInArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SignInResult struct {
	Success *core_api.SignInResp
}

var SignInResult_Success_DEFAULT *core_api.SignInResp

func (p *SignInResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(core_api.SignInResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *SignInResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *SignInResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *SignInResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SignInResult) Unmarshal(in []byte) error {
	msg := new(core_api.SignInResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SignInResult) GetSuccess() *core_api.SignInResp {
	if !p.IsSetSuccess() {
		return SignInResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SignInResult) SetSuccess(x interface{}) {
	p.Success = x.(*core_api.SignInResp)
}

func (p *SignInResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SignInResult) GetResult() interface{} {
	return p.Success
}

func createScheduleHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(core_api.CreateScheduleReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(core_api.CoreApi).CreateSchedule(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateScheduleArgs:
		success, err := handler.(core_api.CoreApi).CreateSchedule(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateScheduleResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateScheduleArgs() interface{} {
	return &CreateScheduleArgs{}
}

func newCreateScheduleResult() interface{} {
	return &CreateScheduleResult{}
}

type CreateScheduleArgs struct {
	Req *core_api.CreateScheduleReq
}

func (p *CreateScheduleArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(core_api.CreateScheduleReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateScheduleArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateScheduleArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateScheduleArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateScheduleArgs) Unmarshal(in []byte) error {
	msg := new(core_api.CreateScheduleReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateScheduleArgs_Req_DEFAULT *core_api.CreateScheduleReq

func (p *CreateScheduleArgs) GetReq() *core_api.CreateScheduleReq {
	if !p.IsSetReq() {
		return CreateScheduleArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateScheduleArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateScheduleArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateScheduleResult struct {
	Success *core_api.CreateScheduleResp
}

var CreateScheduleResult_Success_DEFAULT *core_api.CreateScheduleResp

func (p *CreateScheduleResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(core_api.CreateScheduleResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateScheduleResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateScheduleResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateScheduleResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateScheduleResult) Unmarshal(in []byte) error {
	msg := new(core_api.CreateScheduleResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateScheduleResult) GetSuccess() *core_api.CreateScheduleResp {
	if !p.IsSetSuccess() {
		return CreateScheduleResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateScheduleResult) SetSuccess(x interface{}) {
	p.Success = x.(*core_api.CreateScheduleResp)
}

func (p *CreateScheduleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateScheduleResult) GetResult() interface{} {
	return p.Success
}

func createScheduleFromOriginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(core_api.CreateScheduleFromOriginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(core_api.CoreApi).CreateScheduleFromOrigin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateScheduleFromOriginArgs:
		success, err := handler.(core_api.CoreApi).CreateScheduleFromOrigin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateScheduleFromOriginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateScheduleFromOriginArgs() interface{} {
	return &CreateScheduleFromOriginArgs{}
}

func newCreateScheduleFromOriginResult() interface{} {
	return &CreateScheduleFromOriginResult{}
}

type CreateScheduleFromOriginArgs struct {
	Req *core_api.CreateScheduleFromOriginReq
}

func (p *CreateScheduleFromOriginArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(core_api.CreateScheduleFromOriginReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateScheduleFromOriginArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateScheduleFromOriginArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateScheduleFromOriginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateScheduleFromOriginArgs) Unmarshal(in []byte) error {
	msg := new(core_api.CreateScheduleFromOriginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateScheduleFromOriginArgs_Req_DEFAULT *core_api.CreateScheduleFromOriginReq

func (p *CreateScheduleFromOriginArgs) GetReq() *core_api.CreateScheduleFromOriginReq {
	if !p.IsSetReq() {
		return CreateScheduleFromOriginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateScheduleFromOriginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateScheduleFromOriginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateScheduleFromOriginResult struct {
	Success *core_api.CreateScheduleFromOriginResp
}

var CreateScheduleFromOriginResult_Success_DEFAULT *core_api.CreateScheduleFromOriginResp

func (p *CreateScheduleFromOriginResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(core_api.CreateScheduleFromOriginResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateScheduleFromOriginResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateScheduleFromOriginResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateScheduleFromOriginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateScheduleFromOriginResult) Unmarshal(in []byte) error {
	msg := new(core_api.CreateScheduleFromOriginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateScheduleFromOriginResult) GetSuccess() *core_api.CreateScheduleFromOriginResp {
	if !p.IsSetSuccess() {
		return CreateScheduleFromOriginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateScheduleFromOriginResult) SetSuccess(x interface{}) {
	p.Success = x.(*core_api.CreateScheduleFromOriginResp)
}

func (p *CreateScheduleFromOriginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateScheduleFromOriginResult) GetResult() interface{} {
	return p.Success
}

func createSchedulesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(core_api.CreateSchedulesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(core_api.CoreApi).CreateSchedules(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateSchedulesArgs:
		success, err := handler.(core_api.CoreApi).CreateSchedules(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateSchedulesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateSchedulesArgs() interface{} {
	return &CreateSchedulesArgs{}
}

func newCreateSchedulesResult() interface{} {
	return &CreateSchedulesResult{}
}

type CreateSchedulesArgs struct {
	Req *core_api.CreateSchedulesReq
}

func (p *CreateSchedulesArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(core_api.CreateSchedulesReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateSchedulesArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateSchedulesArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateSchedulesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateSchedulesArgs) Unmarshal(in []byte) error {
	msg := new(core_api.CreateSchedulesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateSchedulesArgs_Req_DEFAULT *core_api.CreateSchedulesReq

func (p *CreateSchedulesArgs) GetReq() *core_api.CreateSchedulesReq {
	if !p.IsSetReq() {
		return CreateSchedulesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateSchedulesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateSchedulesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateSchedulesResult struct {
	Success *core_api.CreateSchedulesResp
}

var CreateSchedulesResult_Success_DEFAULT *core_api.CreateSchedulesResp

func (p *CreateSchedulesResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(core_api.CreateSchedulesResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateSchedulesResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateSchedulesResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateSchedulesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateSchedulesResult) Unmarshal(in []byte) error {
	msg := new(core_api.CreateSchedulesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateSchedulesResult) GetSuccess() *core_api.CreateSchedulesResp {
	if !p.IsSetSuccess() {
		return CreateSchedulesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateSchedulesResult) SetSuccess(x interface{}) {
	p.Success = x.(*core_api.CreateSchedulesResp)
}

func (p *CreateSchedulesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateSchedulesResult) GetResult() interface{} {
	return p.Success
}

func updateScheduleHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(core_api.UpdateScheduleReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(core_api.CoreApi).UpdateSchedule(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateScheduleArgs:
		success, err := handler.(core_api.CoreApi).UpdateSchedule(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateScheduleResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateScheduleArgs() interface{} {
	return &UpdateScheduleArgs{}
}

func newUpdateScheduleResult() interface{} {
	return &UpdateScheduleResult{}
}

type UpdateScheduleArgs struct {
	Req *core_api.UpdateScheduleReq
}

func (p *UpdateScheduleArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(core_api.UpdateScheduleReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateScheduleArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateScheduleArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateScheduleArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateScheduleArgs) Unmarshal(in []byte) error {
	msg := new(core_api.UpdateScheduleReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateScheduleArgs_Req_DEFAULT *core_api.UpdateScheduleReq

func (p *UpdateScheduleArgs) GetReq() *core_api.UpdateScheduleReq {
	if !p.IsSetReq() {
		return UpdateScheduleArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateScheduleArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateScheduleArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateScheduleResult struct {
	Success *core_api.UpdateScheduleResp
}

var UpdateScheduleResult_Success_DEFAULT *core_api.UpdateScheduleResp

func (p *UpdateScheduleResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(core_api.UpdateScheduleResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateScheduleResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateScheduleResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateScheduleResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateScheduleResult) Unmarshal(in []byte) error {
	msg := new(core_api.UpdateScheduleResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateScheduleResult) GetSuccess() *core_api.UpdateScheduleResp {
	if !p.IsSetSuccess() {
		return UpdateScheduleResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateScheduleResult) SetSuccess(x interface{}) {
	p.Success = x.(*core_api.UpdateScheduleResp)
}

func (p *UpdateScheduleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateScheduleResult) GetResult() interface{} {
	return p.Success
}

func getSchedulesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(core_api.GetSchedulesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(core_api.CoreApi).GetSchedules(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetSchedulesArgs:
		success, err := handler.(core_api.CoreApi).GetSchedules(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetSchedulesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetSchedulesArgs() interface{} {
	return &GetSchedulesArgs{}
}

func newGetSchedulesResult() interface{} {
	return &GetSchedulesResult{}
}

type GetSchedulesArgs struct {
	Req *core_api.GetSchedulesReq
}

func (p *GetSchedulesArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(core_api.GetSchedulesReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetSchedulesArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetSchedulesArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetSchedulesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetSchedulesArgs) Unmarshal(in []byte) error {
	msg := new(core_api.GetSchedulesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetSchedulesArgs_Req_DEFAULT *core_api.GetSchedulesReq

func (p *GetSchedulesArgs) GetReq() *core_api.GetSchedulesReq {
	if !p.IsSetReq() {
		return GetSchedulesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetSchedulesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetSchedulesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetSchedulesResult struct {
	Success *core_api.GetSchedulesResp
}

var GetSchedulesResult_Success_DEFAULT *core_api.GetSchedulesResp

func (p *GetSchedulesResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(core_api.GetSchedulesResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetSchedulesResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetSchedulesResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetSchedulesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetSchedulesResult) Unmarshal(in []byte) error {
	msg := new(core_api.GetSchedulesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetSchedulesResult) GetSuccess() *core_api.GetSchedulesResp {
	if !p.IsSetSuccess() {
		return GetSchedulesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetSchedulesResult) SetSuccess(x interface{}) {
	p.Success = x.(*core_api.GetSchedulesResp)
}

func (p *GetSchedulesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSchedulesResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) SignUp(ctx context.Context, Req *core_api.SignUpReq) (r *core_api.SignUpResp, err error) {
	var _args SignUpArgs
	_args.Req = Req
	var _result SignUpResult
	if err = p.c.Call(ctx, "SignUp", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SignIn(ctx context.Context, Req *core_api.SignInReq) (r *core_api.SignInResp, err error) {
	var _args SignInArgs
	_args.Req = Req
	var _result SignInResult
	if err = p.c.Call(ctx, "SignIn", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateSchedule(ctx context.Context, Req *core_api.CreateScheduleReq) (r *core_api.CreateScheduleResp, err error) {
	var _args CreateScheduleArgs
	_args.Req = Req
	var _result CreateScheduleResult
	if err = p.c.Call(ctx, "CreateSchedule", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateScheduleFromOrigin(ctx context.Context, Req *core_api.CreateScheduleFromOriginReq) (r *core_api.CreateScheduleFromOriginResp, err error) {
	var _args CreateScheduleFromOriginArgs
	_args.Req = Req
	var _result CreateScheduleFromOriginResult
	if err = p.c.Call(ctx, "CreateScheduleFromOrigin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateSchedules(ctx context.Context, Req *core_api.CreateSchedulesReq) (r *core_api.CreateSchedulesResp, err error) {
	var _args CreateSchedulesArgs
	_args.Req = Req
	var _result CreateSchedulesResult
	if err = p.c.Call(ctx, "CreateSchedules", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateSchedule(ctx context.Context, Req *core_api.UpdateScheduleReq) (r *core_api.UpdateScheduleResp, err error) {
	var _args UpdateScheduleArgs
	_args.Req = Req
	var _result UpdateScheduleResult
	if err = p.c.Call(ctx, "UpdateSchedule", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetSchedules(ctx context.Context, Req *core_api.GetSchedulesReq) (r *core_api.GetSchedulesResp, err error) {
	var _args GetSchedulesArgs
	_args.Req = Req
	var _result GetSchedulesResult
	if err = p.c.Call(ctx, "GetSchedules", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
