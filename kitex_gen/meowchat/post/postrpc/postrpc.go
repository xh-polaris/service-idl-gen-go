// Code generated by Kitex v0.6.1. DO NOT EDIT.

package postrpc

import (
	"context"
	"fmt"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	post "github.com/xh-polaris/service-idl-gen-go/kitex_gen/meowchat/post"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return postRpcServiceInfo
}

var postRpcServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "post_rpc"
	handlerType := (*post.PostRpc)(nil)
	methods := map[string]kitex.MethodInfo{
		"CreatePost":   kitex.NewMethodInfo(createPostHandler, newCreatePostArgs, newCreatePostResult, false),
		"RetrievePost": kitex.NewMethodInfo(retrievePostHandler, newRetrievePostArgs, newRetrievePostResult, false),
		"UpdatePost":   kitex.NewMethodInfo(updatePostHandler, newUpdatePostArgs, newUpdatePostResult, false),
		"DeletePost":   kitex.NewMethodInfo(deletePostHandler, newDeletePostArgs, newDeletePostResult, false),
		"ListPost":     kitex.NewMethodInfo(listPostHandler, newListPostArgs, newListPostResult, false),
		"CountPost":    kitex.NewMethodInfo(countPostHandler, newCountPostArgs, newCountPostResult, false),
		"SetOfficial":  kitex.NewMethodInfo(setOfficialHandler, newSetOfficialArgs, newSetOfficialResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "meowchat.post",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.6.1",
		Extra:           extra,
	}
	return svcInfo
}

func createPostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(post.CreatePostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(post.PostRpc).CreatePost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreatePostArgs:
		success, err := handler.(post.PostRpc).CreatePost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreatePostResult)
		realResult.Success = success
	}
	return nil
}
func newCreatePostArgs() interface{} {
	return &CreatePostArgs{}
}

func newCreatePostResult() interface{} {
	return &CreatePostResult{}
}

type CreatePostArgs struct {
	Req *post.CreatePostReq
}

func (p *CreatePostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(post.CreatePostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreatePostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreatePostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreatePostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreatePostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreatePostArgs) Unmarshal(in []byte) error {
	msg := new(post.CreatePostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreatePostArgs_Req_DEFAULT *post.CreatePostReq

func (p *CreatePostArgs) GetReq() *post.CreatePostReq {
	if !p.IsSetReq() {
		return CreatePostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreatePostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreatePostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreatePostResult struct {
	Success *post.CreatePostResp
}

var CreatePostResult_Success_DEFAULT *post.CreatePostResp

func (p *CreatePostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(post.CreatePostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreatePostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreatePostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreatePostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreatePostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreatePostResult) Unmarshal(in []byte) error {
	msg := new(post.CreatePostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreatePostResult) GetSuccess() *post.CreatePostResp {
	if !p.IsSetSuccess() {
		return CreatePostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreatePostResult) SetSuccess(x interface{}) {
	p.Success = x.(*post.CreatePostResp)
}

func (p *CreatePostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreatePostResult) GetResult() interface{} {
	return p.Success
}

func retrievePostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(post.RetrievePostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(post.PostRpc).RetrievePost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RetrievePostArgs:
		success, err := handler.(post.PostRpc).RetrievePost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RetrievePostResult)
		realResult.Success = success
	}
	return nil
}
func newRetrievePostArgs() interface{} {
	return &RetrievePostArgs{}
}

func newRetrievePostResult() interface{} {
	return &RetrievePostResult{}
}

type RetrievePostArgs struct {
	Req *post.RetrievePostReq
}

func (p *RetrievePostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(post.RetrievePostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RetrievePostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RetrievePostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RetrievePostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RetrievePostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RetrievePostArgs) Unmarshal(in []byte) error {
	msg := new(post.RetrievePostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RetrievePostArgs_Req_DEFAULT *post.RetrievePostReq

func (p *RetrievePostArgs) GetReq() *post.RetrievePostReq {
	if !p.IsSetReq() {
		return RetrievePostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RetrievePostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RetrievePostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RetrievePostResult struct {
	Success *post.RetrievePostResp
}

var RetrievePostResult_Success_DEFAULT *post.RetrievePostResp

func (p *RetrievePostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(post.RetrievePostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RetrievePostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RetrievePostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RetrievePostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RetrievePostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RetrievePostResult) Unmarshal(in []byte) error {
	msg := new(post.RetrievePostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RetrievePostResult) GetSuccess() *post.RetrievePostResp {
	if !p.IsSetSuccess() {
		return RetrievePostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RetrievePostResult) SetSuccess(x interface{}) {
	p.Success = x.(*post.RetrievePostResp)
}

func (p *RetrievePostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RetrievePostResult) GetResult() interface{} {
	return p.Success
}

func updatePostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(post.UpdatePostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(post.PostRpc).UpdatePost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdatePostArgs:
		success, err := handler.(post.PostRpc).UpdatePost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdatePostResult)
		realResult.Success = success
	}
	return nil
}
func newUpdatePostArgs() interface{} {
	return &UpdatePostArgs{}
}

func newUpdatePostResult() interface{} {
	return &UpdatePostResult{}
}

type UpdatePostArgs struct {
	Req *post.UpdatePostReq
}

func (p *UpdatePostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(post.UpdatePostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdatePostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdatePostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdatePostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UpdatePostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UpdatePostArgs) Unmarshal(in []byte) error {
	msg := new(post.UpdatePostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdatePostArgs_Req_DEFAULT *post.UpdatePostReq

func (p *UpdatePostArgs) GetReq() *post.UpdatePostReq {
	if !p.IsSetReq() {
		return UpdatePostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdatePostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdatePostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdatePostResult struct {
	Success *post.UpdatePostResp
}

var UpdatePostResult_Success_DEFAULT *post.UpdatePostResp

func (p *UpdatePostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(post.UpdatePostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdatePostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdatePostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdatePostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UpdatePostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UpdatePostResult) Unmarshal(in []byte) error {
	msg := new(post.UpdatePostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdatePostResult) GetSuccess() *post.UpdatePostResp {
	if !p.IsSetSuccess() {
		return UpdatePostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdatePostResult) SetSuccess(x interface{}) {
	p.Success = x.(*post.UpdatePostResp)
}

func (p *UpdatePostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdatePostResult) GetResult() interface{} {
	return p.Success
}

func deletePostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(post.DeletePostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(post.PostRpc).DeletePost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeletePostArgs:
		success, err := handler.(post.PostRpc).DeletePost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeletePostResult)
		realResult.Success = success
	}
	return nil
}
func newDeletePostArgs() interface{} {
	return &DeletePostArgs{}
}

func newDeletePostResult() interface{} {
	return &DeletePostResult{}
}

type DeletePostArgs struct {
	Req *post.DeletePostReq
}

func (p *DeletePostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(post.DeletePostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeletePostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeletePostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeletePostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeletePostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeletePostArgs) Unmarshal(in []byte) error {
	msg := new(post.DeletePostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeletePostArgs_Req_DEFAULT *post.DeletePostReq

func (p *DeletePostArgs) GetReq() *post.DeletePostReq {
	if !p.IsSetReq() {
		return DeletePostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeletePostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeletePostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeletePostResult struct {
	Success *post.DeletePostResp
}

var DeletePostResult_Success_DEFAULT *post.DeletePostResp

func (p *DeletePostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(post.DeletePostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeletePostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeletePostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeletePostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeletePostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeletePostResult) Unmarshal(in []byte) error {
	msg := new(post.DeletePostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeletePostResult) GetSuccess() *post.DeletePostResp {
	if !p.IsSetSuccess() {
		return DeletePostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeletePostResult) SetSuccess(x interface{}) {
	p.Success = x.(*post.DeletePostResp)
}

func (p *DeletePostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeletePostResult) GetResult() interface{} {
	return p.Success
}

func listPostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(post.ListPostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(post.PostRpc).ListPost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListPostArgs:
		success, err := handler.(post.PostRpc).ListPost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListPostResult)
		realResult.Success = success
	}
	return nil
}
func newListPostArgs() interface{} {
	return &ListPostArgs{}
}

func newListPostResult() interface{} {
	return &ListPostResult{}
}

type ListPostArgs struct {
	Req *post.ListPostReq
}

func (p *ListPostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(post.ListPostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListPostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListPostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListPostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListPostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListPostArgs) Unmarshal(in []byte) error {
	msg := new(post.ListPostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListPostArgs_Req_DEFAULT *post.ListPostReq

func (p *ListPostArgs) GetReq() *post.ListPostReq {
	if !p.IsSetReq() {
		return ListPostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListPostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListPostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListPostResult struct {
	Success *post.ListPostResp
}

var ListPostResult_Success_DEFAULT *post.ListPostResp

func (p *ListPostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(post.ListPostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListPostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListPostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListPostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListPostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListPostResult) Unmarshal(in []byte) error {
	msg := new(post.ListPostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListPostResult) GetSuccess() *post.ListPostResp {
	if !p.IsSetSuccess() {
		return ListPostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListPostResult) SetSuccess(x interface{}) {
	p.Success = x.(*post.ListPostResp)
}

func (p *ListPostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListPostResult) GetResult() interface{} {
	return p.Success
}

func countPostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(post.CountPostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(post.PostRpc).CountPost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CountPostArgs:
		success, err := handler.(post.PostRpc).CountPost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CountPostResult)
		realResult.Success = success
	}
	return nil
}
func newCountPostArgs() interface{} {
	return &CountPostArgs{}
}

func newCountPostResult() interface{} {
	return &CountPostResult{}
}

type CountPostArgs struct {
	Req *post.CountPostReq
}

func (p *CountPostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(post.CountPostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CountPostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CountPostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CountPostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CountPostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CountPostArgs) Unmarshal(in []byte) error {
	msg := new(post.CountPostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CountPostArgs_Req_DEFAULT *post.CountPostReq

func (p *CountPostArgs) GetReq() *post.CountPostReq {
	if !p.IsSetReq() {
		return CountPostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CountPostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CountPostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CountPostResult struct {
	Success *post.CountPostResp
}

var CountPostResult_Success_DEFAULT *post.CountPostResp

func (p *CountPostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(post.CountPostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CountPostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CountPostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CountPostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CountPostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CountPostResult) Unmarshal(in []byte) error {
	msg := new(post.CountPostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CountPostResult) GetSuccess() *post.CountPostResp {
	if !p.IsSetSuccess() {
		return CountPostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CountPostResult) SetSuccess(x interface{}) {
	p.Success = x.(*post.CountPostResp)
}

func (p *CountPostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CountPostResult) GetResult() interface{} {
	return p.Success
}

func setOfficialHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(post.SetOfficialReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(post.PostRpc).SetOfficial(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SetOfficialArgs:
		success, err := handler.(post.PostRpc).SetOfficial(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SetOfficialResult)
		realResult.Success = success
	}
	return nil
}
func newSetOfficialArgs() interface{} {
	return &SetOfficialArgs{}
}

func newSetOfficialResult() interface{} {
	return &SetOfficialResult{}
}

type SetOfficialArgs struct {
	Req *post.SetOfficialReq
}

func (p *SetOfficialArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(post.SetOfficialReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *SetOfficialArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *SetOfficialArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *SetOfficialArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SetOfficialArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SetOfficialArgs) Unmarshal(in []byte) error {
	msg := new(post.SetOfficialReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SetOfficialArgs_Req_DEFAULT *post.SetOfficialReq

func (p *SetOfficialArgs) GetReq() *post.SetOfficialReq {
	if !p.IsSetReq() {
		return SetOfficialArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SetOfficialArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SetOfficialArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SetOfficialResult struct {
	Success *post.SetOfficialResp
}

var SetOfficialResult_Success_DEFAULT *post.SetOfficialResp

func (p *SetOfficialResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(post.SetOfficialResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *SetOfficialResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *SetOfficialResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *SetOfficialResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SetOfficialResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SetOfficialResult) Unmarshal(in []byte) error {
	msg := new(post.SetOfficialResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SetOfficialResult) GetSuccess() *post.SetOfficialResp {
	if !p.IsSetSuccess() {
		return SetOfficialResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SetOfficialResult) SetSuccess(x interface{}) {
	p.Success = x.(*post.SetOfficialResp)
}

func (p *SetOfficialResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SetOfficialResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreatePost(ctx context.Context, Req *post.CreatePostReq) (r *post.CreatePostResp, err error) {
	var _args CreatePostArgs
	_args.Req = Req
	var _result CreatePostResult
	if err = p.c.Call(ctx, "CreatePost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RetrievePost(ctx context.Context, Req *post.RetrievePostReq) (r *post.RetrievePostResp, err error) {
	var _args RetrievePostArgs
	_args.Req = Req
	var _result RetrievePostResult
	if err = p.c.Call(ctx, "RetrievePost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdatePost(ctx context.Context, Req *post.UpdatePostReq) (r *post.UpdatePostResp, err error) {
	var _args UpdatePostArgs
	_args.Req = Req
	var _result UpdatePostResult
	if err = p.c.Call(ctx, "UpdatePost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeletePost(ctx context.Context, Req *post.DeletePostReq) (r *post.DeletePostResp, err error) {
	var _args DeletePostArgs
	_args.Req = Req
	var _result DeletePostResult
	if err = p.c.Call(ctx, "DeletePost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListPost(ctx context.Context, Req *post.ListPostReq) (r *post.ListPostResp, err error) {
	var _args ListPostArgs
	_args.Req = Req
	var _result ListPostResult
	if err = p.c.Call(ctx, "ListPost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CountPost(ctx context.Context, Req *post.CountPostReq) (r *post.CountPostResp, err error) {
	var _args CountPostArgs
	_args.Req = Req
	var _result CountPostResult
	if err = p.c.Call(ctx, "CountPost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SetOfficial(ctx context.Context, Req *post.SetOfficialReq) (r *post.SetOfficialResp, err error) {
	var _args SetOfficialArgs
	_args.Req = Req
	var _result SetOfficialResult
	if err = p.c.Call(ctx, "SetOfficial", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
