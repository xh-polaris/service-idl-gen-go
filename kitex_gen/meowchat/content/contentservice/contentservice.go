// Code generated by Kitex v0.6.2. DO NOT EDIT.

package contentservice

import (
	"context"
	"fmt"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	content "github.com/xh-polaris/service-idl-gen-go/kitex_gen/meowchat/content"
	proto "google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return contentServiceServiceInfo
}

var contentServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "ContentService"
	handlerType := (*content.ContentService)(nil)
	methods := map[string]kitex.MethodInfo{
		"SearchCat":      kitex.NewMethodInfo(searchCatHandler, newSearchCatArgs, newSearchCatResult, false),
		"ListCat":        kitex.NewMethodInfo(listCatHandler, newListCatArgs, newListCatResult, false),
		"RetrieveCat":    kitex.NewMethodInfo(retrieveCatHandler, newRetrieveCatArgs, newRetrieveCatResult, false),
		"CreateCat":      kitex.NewMethodInfo(createCatHandler, newCreateCatArgs, newCreateCatResult, false),
		"UpdateCat":      kitex.NewMethodInfo(updateCatHandler, newUpdateCatArgs, newUpdateCatResult, false),
		"DeleteCat":      kitex.NewMethodInfo(deleteCatHandler, newDeleteCatArgs, newDeleteCatResult, false),
		"CreateImage":    kitex.NewMethodInfo(createImageHandler, newCreateImageArgs, newCreateImageResult, false),
		"DeleteImage":    kitex.NewMethodInfo(deleteImageHandler, newDeleteImageArgs, newDeleteImageResult, false),
		"ListImage":      kitex.NewMethodInfo(listImageHandler, newListImageArgs, newListImageResult, false),
		"ListMoment":     kitex.NewMethodInfo(listMomentHandler, newListMomentArgs, newListMomentResult, false),
		"CountMoment":    kitex.NewMethodInfo(countMomentHandler, newCountMomentArgs, newCountMomentResult, false),
		"RetrieveMoment": kitex.NewMethodInfo(retrieveMomentHandler, newRetrieveMomentArgs, newRetrieveMomentResult, false),
		"CreateMoment":   kitex.NewMethodInfo(createMomentHandler, newCreateMomentArgs, newCreateMomentResult, false),
		"UpdateMoment":   kitex.NewMethodInfo(updateMomentHandler, newUpdateMomentArgs, newUpdateMomentResult, false),
		"DeleteMoment":   kitex.NewMethodInfo(deleteMomentHandler, newDeleteMomentArgs, newDeleteMomentResult, false),
		"CreatePost":     kitex.NewMethodInfo(createPostHandler, newCreatePostArgs, newCreatePostResult, false),
		"RetrievePost":   kitex.NewMethodInfo(retrievePostHandler, newRetrievePostArgs, newRetrievePostResult, false),
		"UpdatePost":     kitex.NewMethodInfo(updatePostHandler, newUpdatePostArgs, newUpdatePostResult, false),
		"DeletePost":     kitex.NewMethodInfo(deletePostHandler, newDeletePostArgs, newDeletePostResult, false),
		"ListPost":       kitex.NewMethodInfo(listPostHandler, newListPostArgs, newListPostResult, false),
		"CountPost":      kitex.NewMethodInfo(countPostHandler, newCountPostArgs, newCountPostResult, false),
		"SetOfficial":    kitex.NewMethodInfo(setOfficialHandler, newSetOfficialArgs, newSetOfficialResult, false),
		"ListPlan":       kitex.NewMethodInfo(listPlanHandler, newListPlanArgs, newListPlanResult, false),
		"CountPlan":      kitex.NewMethodInfo(countPlanHandler, newCountPlanArgs, newCountPlanResult, false),
		"RetrievePlan":   kitex.NewMethodInfo(retrievePlanHandler, newRetrievePlanArgs, newRetrievePlanResult, false),
		"CreatePlan":     kitex.NewMethodInfo(createPlanHandler, newCreatePlanArgs, newCreatePlanResult, false),
		"UpdatePlan":     kitex.NewMethodInfo(updatePlanHandler, newUpdatePlanArgs, newUpdatePlanResult, false),
		"DeletePlan":     kitex.NewMethodInfo(deletePlanHandler, newDeletePlanArgs, newDeletePlanResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "meowchat.content",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.6.2",
		Extra:           extra,
	}
	return svcInfo
}

func searchCatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.SearchCatReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).SearchCat(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SearchCatArgs:
		success, err := handler.(content.ContentService).SearchCat(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchCatResult)
		realResult.Success = success
	}
	return nil
}
func newSearchCatArgs() interface{} {
	return &SearchCatArgs{}
}

func newSearchCatResult() interface{} {
	return &SearchCatResult{}
}

type SearchCatArgs struct {
	Req *content.SearchCatReq
}

func (p *SearchCatArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.SearchCatReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *SearchCatArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *SearchCatArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *SearchCatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SearchCatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SearchCatArgs) Unmarshal(in []byte) error {
	msg := new(content.SearchCatReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchCatArgs_Req_DEFAULT *content.SearchCatReq

func (p *SearchCatArgs) GetReq() *content.SearchCatReq {
	if !p.IsSetReq() {
		return SearchCatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchCatArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchCatArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchCatResult struct {
	Success *content.SearchCatResp
}

var SearchCatResult_Success_DEFAULT *content.SearchCatResp

func (p *SearchCatResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.SearchCatResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *SearchCatResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *SearchCatResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *SearchCatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SearchCatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SearchCatResult) Unmarshal(in []byte) error {
	msg := new(content.SearchCatResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchCatResult) GetSuccess() *content.SearchCatResp {
	if !p.IsSetSuccess() {
		return SearchCatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchCatResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.SearchCatResp)
}

func (p *SearchCatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchCatResult) GetResult() interface{} {
	return p.Success
}

func listCatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.ListCatReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).ListCat(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListCatArgs:
		success, err := handler.(content.ContentService).ListCat(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListCatResult)
		realResult.Success = success
	}
	return nil
}
func newListCatArgs() interface{} {
	return &ListCatArgs{}
}

func newListCatResult() interface{} {
	return &ListCatResult{}
}

type ListCatArgs struct {
	Req *content.ListCatReq
}

func (p *ListCatArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.ListCatReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListCatArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListCatArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListCatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListCatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListCatArgs) Unmarshal(in []byte) error {
	msg := new(content.ListCatReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListCatArgs_Req_DEFAULT *content.ListCatReq

func (p *ListCatArgs) GetReq() *content.ListCatReq {
	if !p.IsSetReq() {
		return ListCatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListCatArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListCatArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListCatResult struct {
	Success *content.ListCatResp
}

var ListCatResult_Success_DEFAULT *content.ListCatResp

func (p *ListCatResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.ListCatResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListCatResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListCatResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListCatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListCatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListCatResult) Unmarshal(in []byte) error {
	msg := new(content.ListCatResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListCatResult) GetSuccess() *content.ListCatResp {
	if !p.IsSetSuccess() {
		return ListCatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListCatResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.ListCatResp)
}

func (p *ListCatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListCatResult) GetResult() interface{} {
	return p.Success
}

func retrieveCatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.RetrieveCatReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).RetrieveCat(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RetrieveCatArgs:
		success, err := handler.(content.ContentService).RetrieveCat(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RetrieveCatResult)
		realResult.Success = success
	}
	return nil
}
func newRetrieveCatArgs() interface{} {
	return &RetrieveCatArgs{}
}

func newRetrieveCatResult() interface{} {
	return &RetrieveCatResult{}
}

type RetrieveCatArgs struct {
	Req *content.RetrieveCatReq
}

func (p *RetrieveCatArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.RetrieveCatReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RetrieveCatArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RetrieveCatArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RetrieveCatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RetrieveCatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RetrieveCatArgs) Unmarshal(in []byte) error {
	msg := new(content.RetrieveCatReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RetrieveCatArgs_Req_DEFAULT *content.RetrieveCatReq

func (p *RetrieveCatArgs) GetReq() *content.RetrieveCatReq {
	if !p.IsSetReq() {
		return RetrieveCatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RetrieveCatArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RetrieveCatArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RetrieveCatResult struct {
	Success *content.RetrieveCatResp
}

var RetrieveCatResult_Success_DEFAULT *content.RetrieveCatResp

func (p *RetrieveCatResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.RetrieveCatResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RetrieveCatResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RetrieveCatResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RetrieveCatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RetrieveCatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RetrieveCatResult) Unmarshal(in []byte) error {
	msg := new(content.RetrieveCatResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RetrieveCatResult) GetSuccess() *content.RetrieveCatResp {
	if !p.IsSetSuccess() {
		return RetrieveCatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RetrieveCatResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.RetrieveCatResp)
}

func (p *RetrieveCatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RetrieveCatResult) GetResult() interface{} {
	return p.Success
}

func createCatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CreateCatReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CreateCat(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateCatArgs:
		success, err := handler.(content.ContentService).CreateCat(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateCatResult)
		realResult.Success = success
	}
	return nil
}
func newCreateCatArgs() interface{} {
	return &CreateCatArgs{}
}

func newCreateCatResult() interface{} {
	return &CreateCatResult{}
}

type CreateCatArgs struct {
	Req *content.CreateCatReq
}

func (p *CreateCatArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CreateCatReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateCatArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateCatArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateCatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateCatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateCatArgs) Unmarshal(in []byte) error {
	msg := new(content.CreateCatReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateCatArgs_Req_DEFAULT *content.CreateCatReq

func (p *CreateCatArgs) GetReq() *content.CreateCatReq {
	if !p.IsSetReq() {
		return CreateCatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateCatArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateCatArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateCatResult struct {
	Success *content.CreateCatResp
}

var CreateCatResult_Success_DEFAULT *content.CreateCatResp

func (p *CreateCatResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CreateCatResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateCatResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateCatResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateCatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateCatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateCatResult) Unmarshal(in []byte) error {
	msg := new(content.CreateCatResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateCatResult) GetSuccess() *content.CreateCatResp {
	if !p.IsSetSuccess() {
		return CreateCatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateCatResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CreateCatResp)
}

func (p *CreateCatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateCatResult) GetResult() interface{} {
	return p.Success
}

func updateCatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.UpdateCatReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).UpdateCat(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateCatArgs:
		success, err := handler.(content.ContentService).UpdateCat(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateCatResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateCatArgs() interface{} {
	return &UpdateCatArgs{}
}

func newUpdateCatResult() interface{} {
	return &UpdateCatResult{}
}

type UpdateCatArgs struct {
	Req *content.UpdateCatReq
}

func (p *UpdateCatArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.UpdateCatReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateCatArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateCatArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateCatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UpdateCatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateCatArgs) Unmarshal(in []byte) error {
	msg := new(content.UpdateCatReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateCatArgs_Req_DEFAULT *content.UpdateCatReq

func (p *UpdateCatArgs) GetReq() *content.UpdateCatReq {
	if !p.IsSetReq() {
		return UpdateCatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateCatArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateCatArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateCatResult struct {
	Success *content.UpdateCatResp
}

var UpdateCatResult_Success_DEFAULT *content.UpdateCatResp

func (p *UpdateCatResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.UpdateCatResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateCatResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateCatResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateCatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UpdateCatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateCatResult) Unmarshal(in []byte) error {
	msg := new(content.UpdateCatResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateCatResult) GetSuccess() *content.UpdateCatResp {
	if !p.IsSetSuccess() {
		return UpdateCatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateCatResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.UpdateCatResp)
}

func (p *UpdateCatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateCatResult) GetResult() interface{} {
	return p.Success
}

func deleteCatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteCatReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteCat(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteCatArgs:
		success, err := handler.(content.ContentService).DeleteCat(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteCatResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteCatArgs() interface{} {
	return &DeleteCatArgs{}
}

func newDeleteCatResult() interface{} {
	return &DeleteCatResult{}
}

type DeleteCatArgs struct {
	Req *content.DeleteCatReq
}

func (p *DeleteCatArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteCatReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteCatArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteCatArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteCatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteCatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteCatArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteCatReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteCatArgs_Req_DEFAULT *content.DeleteCatReq

func (p *DeleteCatArgs) GetReq() *content.DeleteCatReq {
	if !p.IsSetReq() {
		return DeleteCatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteCatArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteCatArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteCatResult struct {
	Success *content.DeleteCatResp
}

var DeleteCatResult_Success_DEFAULT *content.DeleteCatResp

func (p *DeleteCatResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteCatResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteCatResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteCatResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteCatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteCatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteCatResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteCatResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteCatResult) GetSuccess() *content.DeleteCatResp {
	if !p.IsSetSuccess() {
		return DeleteCatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteCatResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteCatResp)
}

func (p *DeleteCatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteCatResult) GetResult() interface{} {
	return p.Success
}

func createImageHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CreateImageReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CreateImage(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateImageArgs:
		success, err := handler.(content.ContentService).CreateImage(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateImageResult)
		realResult.Success = success
	}
	return nil
}
func newCreateImageArgs() interface{} {
	return &CreateImageArgs{}
}

func newCreateImageResult() interface{} {
	return &CreateImageResult{}
}

type CreateImageArgs struct {
	Req *content.CreateImageReq
}

func (p *CreateImageArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CreateImageReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateImageArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateImageArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateImageArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateImageArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateImageArgs) Unmarshal(in []byte) error {
	msg := new(content.CreateImageReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateImageArgs_Req_DEFAULT *content.CreateImageReq

func (p *CreateImageArgs) GetReq() *content.CreateImageReq {
	if !p.IsSetReq() {
		return CreateImageArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateImageArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateImageArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateImageResult struct {
	Success *content.CreateImageResp
}

var CreateImageResult_Success_DEFAULT *content.CreateImageResp

func (p *CreateImageResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CreateImageResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateImageResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateImageResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateImageResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateImageResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateImageResult) Unmarshal(in []byte) error {
	msg := new(content.CreateImageResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateImageResult) GetSuccess() *content.CreateImageResp {
	if !p.IsSetSuccess() {
		return CreateImageResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateImageResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CreateImageResp)
}

func (p *CreateImageResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateImageResult) GetResult() interface{} {
	return p.Success
}

func deleteImageHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteImageReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteImage(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteImageArgs:
		success, err := handler.(content.ContentService).DeleteImage(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteImageResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteImageArgs() interface{} {
	return &DeleteImageArgs{}
}

func newDeleteImageResult() interface{} {
	return &DeleteImageResult{}
}

type DeleteImageArgs struct {
	Req *content.DeleteImageReq
}

func (p *DeleteImageArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteImageReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteImageArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteImageArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteImageArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteImageArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteImageArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteImageReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteImageArgs_Req_DEFAULT *content.DeleteImageReq

func (p *DeleteImageArgs) GetReq() *content.DeleteImageReq {
	if !p.IsSetReq() {
		return DeleteImageArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteImageArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteImageArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteImageResult struct {
	Success *content.DeleteImageResp
}

var DeleteImageResult_Success_DEFAULT *content.DeleteImageResp

func (p *DeleteImageResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteImageResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteImageResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteImageResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteImageResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteImageResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteImageResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteImageResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteImageResult) GetSuccess() *content.DeleteImageResp {
	if !p.IsSetSuccess() {
		return DeleteImageResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteImageResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteImageResp)
}

func (p *DeleteImageResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteImageResult) GetResult() interface{} {
	return p.Success
}

func listImageHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.ListImageReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).ListImage(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListImageArgs:
		success, err := handler.(content.ContentService).ListImage(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListImageResult)
		realResult.Success = success
	}
	return nil
}
func newListImageArgs() interface{} {
	return &ListImageArgs{}
}

func newListImageResult() interface{} {
	return &ListImageResult{}
}

type ListImageArgs struct {
	Req *content.ListImageReq
}

func (p *ListImageArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.ListImageReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListImageArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListImageArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListImageArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListImageArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListImageArgs) Unmarshal(in []byte) error {
	msg := new(content.ListImageReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListImageArgs_Req_DEFAULT *content.ListImageReq

func (p *ListImageArgs) GetReq() *content.ListImageReq {
	if !p.IsSetReq() {
		return ListImageArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListImageArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListImageArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListImageResult struct {
	Success *content.ListImageResp
}

var ListImageResult_Success_DEFAULT *content.ListImageResp

func (p *ListImageResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.ListImageResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListImageResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListImageResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListImageResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListImageResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListImageResult) Unmarshal(in []byte) error {
	msg := new(content.ListImageResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListImageResult) GetSuccess() *content.ListImageResp {
	if !p.IsSetSuccess() {
		return ListImageResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListImageResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.ListImageResp)
}

func (p *ListImageResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListImageResult) GetResult() interface{} {
	return p.Success
}

func listMomentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.ListMomentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).ListMoment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListMomentArgs:
		success, err := handler.(content.ContentService).ListMoment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListMomentResult)
		realResult.Success = success
	}
	return nil
}
func newListMomentArgs() interface{} {
	return &ListMomentArgs{}
}

func newListMomentResult() interface{} {
	return &ListMomentResult{}
}

type ListMomentArgs struct {
	Req *content.ListMomentReq
}

func (p *ListMomentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.ListMomentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListMomentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListMomentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListMomentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListMomentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListMomentArgs) Unmarshal(in []byte) error {
	msg := new(content.ListMomentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListMomentArgs_Req_DEFAULT *content.ListMomentReq

func (p *ListMomentArgs) GetReq() *content.ListMomentReq {
	if !p.IsSetReq() {
		return ListMomentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListMomentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListMomentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListMomentResult struct {
	Success *content.ListMomentResp
}

var ListMomentResult_Success_DEFAULT *content.ListMomentResp

func (p *ListMomentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.ListMomentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListMomentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListMomentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListMomentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListMomentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListMomentResult) Unmarshal(in []byte) error {
	msg := new(content.ListMomentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListMomentResult) GetSuccess() *content.ListMomentResp {
	if !p.IsSetSuccess() {
		return ListMomentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListMomentResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.ListMomentResp)
}

func (p *ListMomentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListMomentResult) GetResult() interface{} {
	return p.Success
}

func countMomentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CountMomentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CountMoment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CountMomentArgs:
		success, err := handler.(content.ContentService).CountMoment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CountMomentResult)
		realResult.Success = success
	}
	return nil
}
func newCountMomentArgs() interface{} {
	return &CountMomentArgs{}
}

func newCountMomentResult() interface{} {
	return &CountMomentResult{}
}

type CountMomentArgs struct {
	Req *content.CountMomentReq
}

func (p *CountMomentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CountMomentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CountMomentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CountMomentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CountMomentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CountMomentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CountMomentArgs) Unmarshal(in []byte) error {
	msg := new(content.CountMomentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CountMomentArgs_Req_DEFAULT *content.CountMomentReq

func (p *CountMomentArgs) GetReq() *content.CountMomentReq {
	if !p.IsSetReq() {
		return CountMomentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CountMomentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CountMomentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CountMomentResult struct {
	Success *content.CountMomentResp
}

var CountMomentResult_Success_DEFAULT *content.CountMomentResp

func (p *CountMomentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CountMomentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CountMomentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CountMomentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CountMomentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CountMomentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CountMomentResult) Unmarshal(in []byte) error {
	msg := new(content.CountMomentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CountMomentResult) GetSuccess() *content.CountMomentResp {
	if !p.IsSetSuccess() {
		return CountMomentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CountMomentResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CountMomentResp)
}

func (p *CountMomentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CountMomentResult) GetResult() interface{} {
	return p.Success
}

func retrieveMomentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.RetrieveMomentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).RetrieveMoment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RetrieveMomentArgs:
		success, err := handler.(content.ContentService).RetrieveMoment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RetrieveMomentResult)
		realResult.Success = success
	}
	return nil
}
func newRetrieveMomentArgs() interface{} {
	return &RetrieveMomentArgs{}
}

func newRetrieveMomentResult() interface{} {
	return &RetrieveMomentResult{}
}

type RetrieveMomentArgs struct {
	Req *content.RetrieveMomentReq
}

func (p *RetrieveMomentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.RetrieveMomentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RetrieveMomentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RetrieveMomentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RetrieveMomentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RetrieveMomentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RetrieveMomentArgs) Unmarshal(in []byte) error {
	msg := new(content.RetrieveMomentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RetrieveMomentArgs_Req_DEFAULT *content.RetrieveMomentReq

func (p *RetrieveMomentArgs) GetReq() *content.RetrieveMomentReq {
	if !p.IsSetReq() {
		return RetrieveMomentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RetrieveMomentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RetrieveMomentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RetrieveMomentResult struct {
	Success *content.RetrieveMomentResp
}

var RetrieveMomentResult_Success_DEFAULT *content.RetrieveMomentResp

func (p *RetrieveMomentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.RetrieveMomentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RetrieveMomentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RetrieveMomentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RetrieveMomentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RetrieveMomentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RetrieveMomentResult) Unmarshal(in []byte) error {
	msg := new(content.RetrieveMomentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RetrieveMomentResult) GetSuccess() *content.RetrieveMomentResp {
	if !p.IsSetSuccess() {
		return RetrieveMomentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RetrieveMomentResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.RetrieveMomentResp)
}

func (p *RetrieveMomentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RetrieveMomentResult) GetResult() interface{} {
	return p.Success
}

func createMomentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CreateMomentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CreateMoment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateMomentArgs:
		success, err := handler.(content.ContentService).CreateMoment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateMomentResult)
		realResult.Success = success
	}
	return nil
}
func newCreateMomentArgs() interface{} {
	return &CreateMomentArgs{}
}

func newCreateMomentResult() interface{} {
	return &CreateMomentResult{}
}

type CreateMomentArgs struct {
	Req *content.CreateMomentReq
}

func (p *CreateMomentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CreateMomentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateMomentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateMomentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateMomentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateMomentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateMomentArgs) Unmarshal(in []byte) error {
	msg := new(content.CreateMomentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateMomentArgs_Req_DEFAULT *content.CreateMomentReq

func (p *CreateMomentArgs) GetReq() *content.CreateMomentReq {
	if !p.IsSetReq() {
		return CreateMomentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateMomentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateMomentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateMomentResult struct {
	Success *content.CreateMomentResp
}

var CreateMomentResult_Success_DEFAULT *content.CreateMomentResp

func (p *CreateMomentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CreateMomentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateMomentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateMomentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateMomentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateMomentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateMomentResult) Unmarshal(in []byte) error {
	msg := new(content.CreateMomentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateMomentResult) GetSuccess() *content.CreateMomentResp {
	if !p.IsSetSuccess() {
		return CreateMomentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateMomentResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CreateMomentResp)
}

func (p *CreateMomentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateMomentResult) GetResult() interface{} {
	return p.Success
}

func updateMomentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.UpdateMomentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).UpdateMoment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateMomentArgs:
		success, err := handler.(content.ContentService).UpdateMoment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateMomentResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateMomentArgs() interface{} {
	return &UpdateMomentArgs{}
}

func newUpdateMomentResult() interface{} {
	return &UpdateMomentResult{}
}

type UpdateMomentArgs struct {
	Req *content.UpdateMomentReq
}

func (p *UpdateMomentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.UpdateMomentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateMomentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateMomentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateMomentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UpdateMomentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateMomentArgs) Unmarshal(in []byte) error {
	msg := new(content.UpdateMomentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateMomentArgs_Req_DEFAULT *content.UpdateMomentReq

func (p *UpdateMomentArgs) GetReq() *content.UpdateMomentReq {
	if !p.IsSetReq() {
		return UpdateMomentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateMomentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateMomentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateMomentResult struct {
	Success *content.UpdateMomentResp
}

var UpdateMomentResult_Success_DEFAULT *content.UpdateMomentResp

func (p *UpdateMomentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.UpdateMomentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateMomentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateMomentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateMomentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UpdateMomentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateMomentResult) Unmarshal(in []byte) error {
	msg := new(content.UpdateMomentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateMomentResult) GetSuccess() *content.UpdateMomentResp {
	if !p.IsSetSuccess() {
		return UpdateMomentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateMomentResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.UpdateMomentResp)
}

func (p *UpdateMomentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateMomentResult) GetResult() interface{} {
	return p.Success
}

func deleteMomentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeleteMomentReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeleteMoment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteMomentArgs:
		success, err := handler.(content.ContentService).DeleteMoment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteMomentResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteMomentArgs() interface{} {
	return &DeleteMomentArgs{}
}

func newDeleteMomentResult() interface{} {
	return &DeleteMomentResult{}
}

type DeleteMomentArgs struct {
	Req *content.DeleteMomentReq
}

func (p *DeleteMomentArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeleteMomentReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteMomentArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteMomentArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteMomentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteMomentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteMomentArgs) Unmarshal(in []byte) error {
	msg := new(content.DeleteMomentReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteMomentArgs_Req_DEFAULT *content.DeleteMomentReq

func (p *DeleteMomentArgs) GetReq() *content.DeleteMomentReq {
	if !p.IsSetReq() {
		return DeleteMomentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteMomentArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteMomentArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteMomentResult struct {
	Success *content.DeleteMomentResp
}

var DeleteMomentResult_Success_DEFAULT *content.DeleteMomentResp

func (p *DeleteMomentResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeleteMomentResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteMomentResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteMomentResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteMomentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteMomentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteMomentResult) Unmarshal(in []byte) error {
	msg := new(content.DeleteMomentResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteMomentResult) GetSuccess() *content.DeleteMomentResp {
	if !p.IsSetSuccess() {
		return DeleteMomentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteMomentResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeleteMomentResp)
}

func (p *DeleteMomentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteMomentResult) GetResult() interface{} {
	return p.Success
}

func createPostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CreatePostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CreatePost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreatePostArgs:
		success, err := handler.(content.ContentService).CreatePost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreatePostResult)
		realResult.Success = success
	}
	return nil
}
func newCreatePostArgs() interface{} {
	return &CreatePostArgs{}
}

func newCreatePostResult() interface{} {
	return &CreatePostResult{}
}

type CreatePostArgs struct {
	Req *content.CreatePostReq
}

func (p *CreatePostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CreatePostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreatePostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreatePostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreatePostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreatePostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreatePostArgs) Unmarshal(in []byte) error {
	msg := new(content.CreatePostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreatePostArgs_Req_DEFAULT *content.CreatePostReq

func (p *CreatePostArgs) GetReq() *content.CreatePostReq {
	if !p.IsSetReq() {
		return CreatePostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreatePostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreatePostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreatePostResult struct {
	Success *content.CreatePostResp
}

var CreatePostResult_Success_DEFAULT *content.CreatePostResp

func (p *CreatePostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CreatePostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreatePostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreatePostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreatePostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreatePostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreatePostResult) Unmarshal(in []byte) error {
	msg := new(content.CreatePostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreatePostResult) GetSuccess() *content.CreatePostResp {
	if !p.IsSetSuccess() {
		return CreatePostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreatePostResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CreatePostResp)
}

func (p *CreatePostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreatePostResult) GetResult() interface{} {
	return p.Success
}

func retrievePostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.RetrievePostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).RetrievePost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RetrievePostArgs:
		success, err := handler.(content.ContentService).RetrievePost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RetrievePostResult)
		realResult.Success = success
	}
	return nil
}
func newRetrievePostArgs() interface{} {
	return &RetrievePostArgs{}
}

func newRetrievePostResult() interface{} {
	return &RetrievePostResult{}
}

type RetrievePostArgs struct {
	Req *content.RetrievePostReq
}

func (p *RetrievePostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.RetrievePostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RetrievePostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RetrievePostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RetrievePostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RetrievePostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RetrievePostArgs) Unmarshal(in []byte) error {
	msg := new(content.RetrievePostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RetrievePostArgs_Req_DEFAULT *content.RetrievePostReq

func (p *RetrievePostArgs) GetReq() *content.RetrievePostReq {
	if !p.IsSetReq() {
		return RetrievePostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RetrievePostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RetrievePostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RetrievePostResult struct {
	Success *content.RetrievePostResp
}

var RetrievePostResult_Success_DEFAULT *content.RetrievePostResp

func (p *RetrievePostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.RetrievePostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RetrievePostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RetrievePostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RetrievePostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RetrievePostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RetrievePostResult) Unmarshal(in []byte) error {
	msg := new(content.RetrievePostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RetrievePostResult) GetSuccess() *content.RetrievePostResp {
	if !p.IsSetSuccess() {
		return RetrievePostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RetrievePostResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.RetrievePostResp)
}

func (p *RetrievePostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RetrievePostResult) GetResult() interface{} {
	return p.Success
}

func updatePostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.UpdatePostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).UpdatePost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdatePostArgs:
		success, err := handler.(content.ContentService).UpdatePost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdatePostResult)
		realResult.Success = success
	}
	return nil
}
func newUpdatePostArgs() interface{} {
	return &UpdatePostArgs{}
}

func newUpdatePostResult() interface{} {
	return &UpdatePostResult{}
}

type UpdatePostArgs struct {
	Req *content.UpdatePostReq
}

func (p *UpdatePostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.UpdatePostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdatePostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdatePostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdatePostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UpdatePostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UpdatePostArgs) Unmarshal(in []byte) error {
	msg := new(content.UpdatePostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdatePostArgs_Req_DEFAULT *content.UpdatePostReq

func (p *UpdatePostArgs) GetReq() *content.UpdatePostReq {
	if !p.IsSetReq() {
		return UpdatePostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdatePostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdatePostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdatePostResult struct {
	Success *content.UpdatePostResp
}

var UpdatePostResult_Success_DEFAULT *content.UpdatePostResp

func (p *UpdatePostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.UpdatePostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdatePostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdatePostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdatePostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UpdatePostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UpdatePostResult) Unmarshal(in []byte) error {
	msg := new(content.UpdatePostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdatePostResult) GetSuccess() *content.UpdatePostResp {
	if !p.IsSetSuccess() {
		return UpdatePostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdatePostResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.UpdatePostResp)
}

func (p *UpdatePostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdatePostResult) GetResult() interface{} {
	return p.Success
}

func deletePostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeletePostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeletePost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeletePostArgs:
		success, err := handler.(content.ContentService).DeletePost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeletePostResult)
		realResult.Success = success
	}
	return nil
}
func newDeletePostArgs() interface{} {
	return &DeletePostArgs{}
}

func newDeletePostResult() interface{} {
	return &DeletePostResult{}
}

type DeletePostArgs struct {
	Req *content.DeletePostReq
}

func (p *DeletePostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeletePostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeletePostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeletePostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeletePostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeletePostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeletePostArgs) Unmarshal(in []byte) error {
	msg := new(content.DeletePostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeletePostArgs_Req_DEFAULT *content.DeletePostReq

func (p *DeletePostArgs) GetReq() *content.DeletePostReq {
	if !p.IsSetReq() {
		return DeletePostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeletePostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeletePostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeletePostResult struct {
	Success *content.DeletePostResp
}

var DeletePostResult_Success_DEFAULT *content.DeletePostResp

func (p *DeletePostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeletePostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeletePostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeletePostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeletePostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeletePostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeletePostResult) Unmarshal(in []byte) error {
	msg := new(content.DeletePostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeletePostResult) GetSuccess() *content.DeletePostResp {
	if !p.IsSetSuccess() {
		return DeletePostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeletePostResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeletePostResp)
}

func (p *DeletePostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeletePostResult) GetResult() interface{} {
	return p.Success
}

func listPostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.ListPostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).ListPost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListPostArgs:
		success, err := handler.(content.ContentService).ListPost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListPostResult)
		realResult.Success = success
	}
	return nil
}
func newListPostArgs() interface{} {
	return &ListPostArgs{}
}

func newListPostResult() interface{} {
	return &ListPostResult{}
}

type ListPostArgs struct {
	Req *content.ListPostReq
}

func (p *ListPostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.ListPostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListPostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListPostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListPostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListPostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListPostArgs) Unmarshal(in []byte) error {
	msg := new(content.ListPostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListPostArgs_Req_DEFAULT *content.ListPostReq

func (p *ListPostArgs) GetReq() *content.ListPostReq {
	if !p.IsSetReq() {
		return ListPostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListPostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListPostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListPostResult struct {
	Success *content.ListPostResp
}

var ListPostResult_Success_DEFAULT *content.ListPostResp

func (p *ListPostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.ListPostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListPostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListPostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListPostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListPostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListPostResult) Unmarshal(in []byte) error {
	msg := new(content.ListPostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListPostResult) GetSuccess() *content.ListPostResp {
	if !p.IsSetSuccess() {
		return ListPostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListPostResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.ListPostResp)
}

func (p *ListPostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListPostResult) GetResult() interface{} {
	return p.Success
}

func countPostHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CountPostReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CountPost(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CountPostArgs:
		success, err := handler.(content.ContentService).CountPost(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CountPostResult)
		realResult.Success = success
	}
	return nil
}
func newCountPostArgs() interface{} {
	return &CountPostArgs{}
}

func newCountPostResult() interface{} {
	return &CountPostResult{}
}

type CountPostArgs struct {
	Req *content.CountPostReq
}

func (p *CountPostArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CountPostReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CountPostArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CountPostArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CountPostArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CountPostArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CountPostArgs) Unmarshal(in []byte) error {
	msg := new(content.CountPostReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CountPostArgs_Req_DEFAULT *content.CountPostReq

func (p *CountPostArgs) GetReq() *content.CountPostReq {
	if !p.IsSetReq() {
		return CountPostArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CountPostArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CountPostArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CountPostResult struct {
	Success *content.CountPostResp
}

var CountPostResult_Success_DEFAULT *content.CountPostResp

func (p *CountPostResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CountPostResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CountPostResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CountPostResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CountPostResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CountPostResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CountPostResult) Unmarshal(in []byte) error {
	msg := new(content.CountPostResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CountPostResult) GetSuccess() *content.CountPostResp {
	if !p.IsSetSuccess() {
		return CountPostResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CountPostResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CountPostResp)
}

func (p *CountPostResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CountPostResult) GetResult() interface{} {
	return p.Success
}

func setOfficialHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.SetOfficialReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).SetOfficial(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SetOfficialArgs:
		success, err := handler.(content.ContentService).SetOfficial(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SetOfficialResult)
		realResult.Success = success
	}
	return nil
}
func newSetOfficialArgs() interface{} {
	return &SetOfficialArgs{}
}

func newSetOfficialResult() interface{} {
	return &SetOfficialResult{}
}

type SetOfficialArgs struct {
	Req *content.SetOfficialReq
}

func (p *SetOfficialArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.SetOfficialReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *SetOfficialArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *SetOfficialArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *SetOfficialArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SetOfficialArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SetOfficialArgs) Unmarshal(in []byte) error {
	msg := new(content.SetOfficialReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SetOfficialArgs_Req_DEFAULT *content.SetOfficialReq

func (p *SetOfficialArgs) GetReq() *content.SetOfficialReq {
	if !p.IsSetReq() {
		return SetOfficialArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SetOfficialArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SetOfficialArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SetOfficialResult struct {
	Success *content.SetOfficialResp
}

var SetOfficialResult_Success_DEFAULT *content.SetOfficialResp

func (p *SetOfficialResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.SetOfficialResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *SetOfficialResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *SetOfficialResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *SetOfficialResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SetOfficialResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SetOfficialResult) Unmarshal(in []byte) error {
	msg := new(content.SetOfficialResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SetOfficialResult) GetSuccess() *content.SetOfficialResp {
	if !p.IsSetSuccess() {
		return SetOfficialResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SetOfficialResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.SetOfficialResp)
}

func (p *SetOfficialResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SetOfficialResult) GetResult() interface{} {
	return p.Success
}

func listPlanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.ListPlanReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).ListPlan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListPlanArgs:
		success, err := handler.(content.ContentService).ListPlan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListPlanResult)
		realResult.Success = success
	}
	return nil
}
func newListPlanArgs() interface{} {
	return &ListPlanArgs{}
}

func newListPlanResult() interface{} {
	return &ListPlanResult{}
}

type ListPlanArgs struct {
	Req *content.ListPlanReq
}

func (p *ListPlanArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.ListPlanReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ListPlanArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ListPlanArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ListPlanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListPlanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListPlanArgs) Unmarshal(in []byte) error {
	msg := new(content.ListPlanReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListPlanArgs_Req_DEFAULT *content.ListPlanReq

func (p *ListPlanArgs) GetReq() *content.ListPlanReq {
	if !p.IsSetReq() {
		return ListPlanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListPlanArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListPlanArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListPlanResult struct {
	Success *content.ListPlanResp
}

var ListPlanResult_Success_DEFAULT *content.ListPlanResp

func (p *ListPlanResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.ListPlanResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ListPlanResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ListPlanResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ListPlanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListPlanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListPlanResult) Unmarshal(in []byte) error {
	msg := new(content.ListPlanResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListPlanResult) GetSuccess() *content.ListPlanResp {
	if !p.IsSetSuccess() {
		return ListPlanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListPlanResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.ListPlanResp)
}

func (p *ListPlanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListPlanResult) GetResult() interface{} {
	return p.Success
}

func countPlanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CountPlanReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CountPlan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CountPlanArgs:
		success, err := handler.(content.ContentService).CountPlan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CountPlanResult)
		realResult.Success = success
	}
	return nil
}
func newCountPlanArgs() interface{} {
	return &CountPlanArgs{}
}

func newCountPlanResult() interface{} {
	return &CountPlanResult{}
}

type CountPlanArgs struct {
	Req *content.CountPlanReq
}

func (p *CountPlanArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CountPlanReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CountPlanArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CountPlanArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CountPlanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CountPlanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CountPlanArgs) Unmarshal(in []byte) error {
	msg := new(content.CountPlanReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CountPlanArgs_Req_DEFAULT *content.CountPlanReq

func (p *CountPlanArgs) GetReq() *content.CountPlanReq {
	if !p.IsSetReq() {
		return CountPlanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CountPlanArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CountPlanArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CountPlanResult struct {
	Success *content.CountPlanResp
}

var CountPlanResult_Success_DEFAULT *content.CountPlanResp

func (p *CountPlanResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CountPlanResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CountPlanResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CountPlanResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CountPlanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CountPlanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CountPlanResult) Unmarshal(in []byte) error {
	msg := new(content.CountPlanResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CountPlanResult) GetSuccess() *content.CountPlanResp {
	if !p.IsSetSuccess() {
		return CountPlanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CountPlanResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CountPlanResp)
}

func (p *CountPlanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CountPlanResult) GetResult() interface{} {
	return p.Success
}

func retrievePlanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.RetrievePlanReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).RetrievePlan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RetrievePlanArgs:
		success, err := handler.(content.ContentService).RetrievePlan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RetrievePlanResult)
		realResult.Success = success
	}
	return nil
}
func newRetrievePlanArgs() interface{} {
	return &RetrievePlanArgs{}
}

func newRetrievePlanResult() interface{} {
	return &RetrievePlanResult{}
}

type RetrievePlanArgs struct {
	Req *content.RetrievePlanReq
}

func (p *RetrievePlanArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.RetrievePlanReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *RetrievePlanArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *RetrievePlanArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *RetrievePlanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RetrievePlanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RetrievePlanArgs) Unmarshal(in []byte) error {
	msg := new(content.RetrievePlanReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RetrievePlanArgs_Req_DEFAULT *content.RetrievePlanReq

func (p *RetrievePlanArgs) GetReq() *content.RetrievePlanReq {
	if !p.IsSetReq() {
		return RetrievePlanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RetrievePlanArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RetrievePlanArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RetrievePlanResult struct {
	Success *content.RetrievePlanResp
}

var RetrievePlanResult_Success_DEFAULT *content.RetrievePlanResp

func (p *RetrievePlanResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.RetrievePlanResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *RetrievePlanResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *RetrievePlanResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *RetrievePlanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RetrievePlanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RetrievePlanResult) Unmarshal(in []byte) error {
	msg := new(content.RetrievePlanResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RetrievePlanResult) GetSuccess() *content.RetrievePlanResp {
	if !p.IsSetSuccess() {
		return RetrievePlanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RetrievePlanResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.RetrievePlanResp)
}

func (p *RetrievePlanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RetrievePlanResult) GetResult() interface{} {
	return p.Success
}

func createPlanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.CreatePlanReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).CreatePlan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreatePlanArgs:
		success, err := handler.(content.ContentService).CreatePlan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreatePlanResult)
		realResult.Success = success
	}
	return nil
}
func newCreatePlanArgs() interface{} {
	return &CreatePlanArgs{}
}

func newCreatePlanResult() interface{} {
	return &CreatePlanResult{}
}

type CreatePlanArgs struct {
	Req *content.CreatePlanReq
}

func (p *CreatePlanArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.CreatePlanReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreatePlanArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreatePlanArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreatePlanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreatePlanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreatePlanArgs) Unmarshal(in []byte) error {
	msg := new(content.CreatePlanReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreatePlanArgs_Req_DEFAULT *content.CreatePlanReq

func (p *CreatePlanArgs) GetReq() *content.CreatePlanReq {
	if !p.IsSetReq() {
		return CreatePlanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreatePlanArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreatePlanArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreatePlanResult struct {
	Success *content.CreatePlanResp
}

var CreatePlanResult_Success_DEFAULT *content.CreatePlanResp

func (p *CreatePlanResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.CreatePlanResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreatePlanResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreatePlanResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreatePlanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreatePlanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreatePlanResult) Unmarshal(in []byte) error {
	msg := new(content.CreatePlanResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreatePlanResult) GetSuccess() *content.CreatePlanResp {
	if !p.IsSetSuccess() {
		return CreatePlanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreatePlanResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.CreatePlanResp)
}

func (p *CreatePlanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreatePlanResult) GetResult() interface{} {
	return p.Success
}

func updatePlanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.UpdatePlanReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).UpdatePlan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdatePlanArgs:
		success, err := handler.(content.ContentService).UpdatePlan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdatePlanResult)
		realResult.Success = success
	}
	return nil
}
func newUpdatePlanArgs() interface{} {
	return &UpdatePlanArgs{}
}

func newUpdatePlanResult() interface{} {
	return &UpdatePlanResult{}
}

type UpdatePlanArgs struct {
	Req *content.UpdatePlanReq
}

func (p *UpdatePlanArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.UpdatePlanReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdatePlanArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdatePlanArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdatePlanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UpdatePlanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UpdatePlanArgs) Unmarshal(in []byte) error {
	msg := new(content.UpdatePlanReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdatePlanArgs_Req_DEFAULT *content.UpdatePlanReq

func (p *UpdatePlanArgs) GetReq() *content.UpdatePlanReq {
	if !p.IsSetReq() {
		return UpdatePlanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdatePlanArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdatePlanArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdatePlanResult struct {
	Success *content.UpdatePlanResp
}

var UpdatePlanResult_Success_DEFAULT *content.UpdatePlanResp

func (p *UpdatePlanResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.UpdatePlanResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdatePlanResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdatePlanResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdatePlanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UpdatePlanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UpdatePlanResult) Unmarshal(in []byte) error {
	msg := new(content.UpdatePlanResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdatePlanResult) GetSuccess() *content.UpdatePlanResp {
	if !p.IsSetSuccess() {
		return UpdatePlanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdatePlanResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.UpdatePlanResp)
}

func (p *UpdatePlanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdatePlanResult) GetResult() interface{} {
	return p.Success
}

func deletePlanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(content.DeletePlanReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(content.ContentService).DeletePlan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeletePlanArgs:
		success, err := handler.(content.ContentService).DeletePlan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeletePlanResult)
		realResult.Success = success
	}
	return nil
}
func newDeletePlanArgs() interface{} {
	return &DeletePlanArgs{}
}

func newDeletePlanResult() interface{} {
	return &DeletePlanResult{}
}

type DeletePlanArgs struct {
	Req *content.DeletePlanReq
}

func (p *DeletePlanArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(content.DeletePlanReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeletePlanArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeletePlanArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeletePlanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeletePlanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeletePlanArgs) Unmarshal(in []byte) error {
	msg := new(content.DeletePlanReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeletePlanArgs_Req_DEFAULT *content.DeletePlanReq

func (p *DeletePlanArgs) GetReq() *content.DeletePlanReq {
	if !p.IsSetReq() {
		return DeletePlanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeletePlanArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeletePlanArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeletePlanResult struct {
	Success *content.DeletePlanResp
}

var DeletePlanResult_Success_DEFAULT *content.DeletePlanResp

func (p *DeletePlanResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(content.DeletePlanResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeletePlanResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeletePlanResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeletePlanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeletePlanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeletePlanResult) Unmarshal(in []byte) error {
	msg := new(content.DeletePlanResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeletePlanResult) GetSuccess() *content.DeletePlanResp {
	if !p.IsSetSuccess() {
		return DeletePlanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeletePlanResult) SetSuccess(x interface{}) {
	p.Success = x.(*content.DeletePlanResp)
}

func (p *DeletePlanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeletePlanResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) SearchCat(ctx context.Context, Req *content.SearchCatReq) (r *content.SearchCatResp, err error) {
	var _args SearchCatArgs
	_args.Req = Req
	var _result SearchCatResult
	if err = p.c.Call(ctx, "SearchCat", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListCat(ctx context.Context, Req *content.ListCatReq) (r *content.ListCatResp, err error) {
	var _args ListCatArgs
	_args.Req = Req
	var _result ListCatResult
	if err = p.c.Call(ctx, "ListCat", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RetrieveCat(ctx context.Context, Req *content.RetrieveCatReq) (r *content.RetrieveCatResp, err error) {
	var _args RetrieveCatArgs
	_args.Req = Req
	var _result RetrieveCatResult
	if err = p.c.Call(ctx, "RetrieveCat", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateCat(ctx context.Context, Req *content.CreateCatReq) (r *content.CreateCatResp, err error) {
	var _args CreateCatArgs
	_args.Req = Req
	var _result CreateCatResult
	if err = p.c.Call(ctx, "CreateCat", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateCat(ctx context.Context, Req *content.UpdateCatReq) (r *content.UpdateCatResp, err error) {
	var _args UpdateCatArgs
	_args.Req = Req
	var _result UpdateCatResult
	if err = p.c.Call(ctx, "UpdateCat", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteCat(ctx context.Context, Req *content.DeleteCatReq) (r *content.DeleteCatResp, err error) {
	var _args DeleteCatArgs
	_args.Req = Req
	var _result DeleteCatResult
	if err = p.c.Call(ctx, "DeleteCat", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateImage(ctx context.Context, Req *content.CreateImageReq) (r *content.CreateImageResp, err error) {
	var _args CreateImageArgs
	_args.Req = Req
	var _result CreateImageResult
	if err = p.c.Call(ctx, "CreateImage", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteImage(ctx context.Context, Req *content.DeleteImageReq) (r *content.DeleteImageResp, err error) {
	var _args DeleteImageArgs
	_args.Req = Req
	var _result DeleteImageResult
	if err = p.c.Call(ctx, "DeleteImage", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListImage(ctx context.Context, Req *content.ListImageReq) (r *content.ListImageResp, err error) {
	var _args ListImageArgs
	_args.Req = Req
	var _result ListImageResult
	if err = p.c.Call(ctx, "ListImage", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListMoment(ctx context.Context, Req *content.ListMomentReq) (r *content.ListMomentResp, err error) {
	var _args ListMomentArgs
	_args.Req = Req
	var _result ListMomentResult
	if err = p.c.Call(ctx, "ListMoment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CountMoment(ctx context.Context, Req *content.CountMomentReq) (r *content.CountMomentResp, err error) {
	var _args CountMomentArgs
	_args.Req = Req
	var _result CountMomentResult
	if err = p.c.Call(ctx, "CountMoment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RetrieveMoment(ctx context.Context, Req *content.RetrieveMomentReq) (r *content.RetrieveMomentResp, err error) {
	var _args RetrieveMomentArgs
	_args.Req = Req
	var _result RetrieveMomentResult
	if err = p.c.Call(ctx, "RetrieveMoment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateMoment(ctx context.Context, Req *content.CreateMomentReq) (r *content.CreateMomentResp, err error) {
	var _args CreateMomentArgs
	_args.Req = Req
	var _result CreateMomentResult
	if err = p.c.Call(ctx, "CreateMoment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateMoment(ctx context.Context, Req *content.UpdateMomentReq) (r *content.UpdateMomentResp, err error) {
	var _args UpdateMomentArgs
	_args.Req = Req
	var _result UpdateMomentResult
	if err = p.c.Call(ctx, "UpdateMoment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteMoment(ctx context.Context, Req *content.DeleteMomentReq) (r *content.DeleteMomentResp, err error) {
	var _args DeleteMomentArgs
	_args.Req = Req
	var _result DeleteMomentResult
	if err = p.c.Call(ctx, "DeleteMoment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreatePost(ctx context.Context, Req *content.CreatePostReq) (r *content.CreatePostResp, err error) {
	var _args CreatePostArgs
	_args.Req = Req
	var _result CreatePostResult
	if err = p.c.Call(ctx, "CreatePost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RetrievePost(ctx context.Context, Req *content.RetrievePostReq) (r *content.RetrievePostResp, err error) {
	var _args RetrievePostArgs
	_args.Req = Req
	var _result RetrievePostResult
	if err = p.c.Call(ctx, "RetrievePost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdatePost(ctx context.Context, Req *content.UpdatePostReq) (r *content.UpdatePostResp, err error) {
	var _args UpdatePostArgs
	_args.Req = Req
	var _result UpdatePostResult
	if err = p.c.Call(ctx, "UpdatePost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeletePost(ctx context.Context, Req *content.DeletePostReq) (r *content.DeletePostResp, err error) {
	var _args DeletePostArgs
	_args.Req = Req
	var _result DeletePostResult
	if err = p.c.Call(ctx, "DeletePost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListPost(ctx context.Context, Req *content.ListPostReq) (r *content.ListPostResp, err error) {
	var _args ListPostArgs
	_args.Req = Req
	var _result ListPostResult
	if err = p.c.Call(ctx, "ListPost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CountPost(ctx context.Context, Req *content.CountPostReq) (r *content.CountPostResp, err error) {
	var _args CountPostArgs
	_args.Req = Req
	var _result CountPostResult
	if err = p.c.Call(ctx, "CountPost", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SetOfficial(ctx context.Context, Req *content.SetOfficialReq) (r *content.SetOfficialResp, err error) {
	var _args SetOfficialArgs
	_args.Req = Req
	var _result SetOfficialResult
	if err = p.c.Call(ctx, "SetOfficial", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListPlan(ctx context.Context, Req *content.ListPlanReq) (r *content.ListPlanResp, err error) {
	var _args ListPlanArgs
	_args.Req = Req
	var _result ListPlanResult
	if err = p.c.Call(ctx, "ListPlan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CountPlan(ctx context.Context, Req *content.CountPlanReq) (r *content.CountPlanResp, err error) {
	var _args CountPlanArgs
	_args.Req = Req
	var _result CountPlanResult
	if err = p.c.Call(ctx, "CountPlan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RetrievePlan(ctx context.Context, Req *content.RetrievePlanReq) (r *content.RetrievePlanResp, err error) {
	var _args RetrievePlanArgs
	_args.Req = Req
	var _result RetrievePlanResult
	if err = p.c.Call(ctx, "RetrievePlan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreatePlan(ctx context.Context, Req *content.CreatePlanReq) (r *content.CreatePlanResp, err error) {
	var _args CreatePlanArgs
	_args.Req = Req
	var _result CreatePlanResult
	if err = p.c.Call(ctx, "CreatePlan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdatePlan(ctx context.Context, Req *content.UpdatePlanReq) (r *content.UpdatePlanResp, err error) {
	var _args UpdatePlanArgs
	_args.Req = Req
	var _result UpdatePlanResult
	if err = p.c.Call(ctx, "UpdatePlan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeletePlan(ctx context.Context, Req *content.DeletePlanReq) (r *content.DeletePlanResp, err error) {
	var _args DeletePlanArgs
	_args.Req = Req
	var _result DeletePlanResult
	if err = p.c.Call(ctx, "DeletePlan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
